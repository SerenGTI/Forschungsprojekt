%!TEX root=../main.tex

\section{Conclusion}

We compared the performance of several graph processing frameworks including Ligra, Polymer, Gemini, Galois and Giraph. 
For comparison we used the three graph algorithms SSSP, BFS and PR on data sets of various sizes.
We measured the calculation time of the algorithm itself and the overall execution time, which also includes the framework overhead.
All of the frameworks were tested on a single compute node. Gemini, Galois and Giraph also support distributed computation and were therefore also tested on a five-node cluster.

On a single node, the fastest framework in computation time is dependent on the problem under consideration.
For SSSP, we found Polymer to perform best while for BFS Ligra and Gemini are fastest. PR was calculated by Galois the fastest.
Depending on the exact circumstances all choices except Giraph can be suitable as single node system. 
When looking at the computation times of the distributed systems, it stands out that the best time for each problem is beaten by most if not all of the single node times.
This suggests that single-node systems should be used whenever there is sufficent RAM.
Comparing the distributed computation times SSSP and BFS results looked similar with Giraph being often the fastest, sometimes beaten by Gemini. The push version of Galois outperforms the pull version but ultimatively was slower than Gemini. For PR, Gemini was the fastest by a margin.
Overall, Gemini is the fastest distributed framework. However Giraph can be a good choice as well, outperforming Gemini at several occations on SSSP and BFS and offering additional features like node fault-tolerance.
In contrast, in terms of overall execution times, Galois almost always outperforms the other frameworks because the overhead is very small.
This makes Galois perfect for individual calculations in a graph, where the loading time of the graph has a great influence.


While comparing the frameworks we have noticed that the performance highly depends on the interaction between framework, algorithm and input graphs.
Therefore there is room for further investigation here. These tests could incorporate new frameworks and new algorithms.
Some of the tested systems offer a great range of settings and multiple implementations for the same problem. It would be interesting to see a comparison there as well.
At a later point in time, it is important to repeat such a comparison, because the frameworks are further developed and new ones are created.
