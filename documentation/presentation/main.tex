\documentclass{meetings}


\usepackage{makecell}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{subcaption}

\usepackage{tikz}
\usetikzlibrary{positioning}

\setlength{\parskip}{0pt}
\setlength{\parindent}{0pt}
\setlength{\columnsep}{1cm}
\raggedcolumns


\author{S. König, L. Matzner, F. Rollbühler and J. Schmid}
\date{Tuesday, 20\textsuperscript{th} October 2020}


\begin{document}
% Ich weiß, dass es die Beamer-Klasse gibt.
% Lasst mich doch alle in Ruhe!
% Die hier hatte ich noch rumliegen, das muss jetzt reichen.
\section{Introduction}
\begin{itemize}
	\item 
In the past years several graph processing systems emerged.
Graphs are growing fast and are becoming increasingly popular. Many problems can be modeled and solved using graphs.
\item Comparison of non-uniform memory access (NUMA) aware systems and Giraph in their performance
\begin{itemize}
	\item on different graphs (real world and synthetic)
\item and different algorithms (SSSP, BFS, PR)
\end{itemize}
\end{itemize}











\clearpage
\section{Overview}


\clearpage
\section{Preliminaries}
\begin{multicols}{2}
\noindent
	A \emph{weighted, directed graph} is the tuple $G=(V,E,w)$ where the \emph{vertex set} is $V\subseteq\mathbb N$ and the $E$ is the \emph{edge set} with
	\begin{equation*}
	  E\subseteq\{(x,y)\,|\, x,y\in V, x\neq y\}
	\end{equation*}
	and $w:E\rightarrow \mathbb R$ is a mapping of edge to a weight.
	
	\begin{center}
	\begin{tikzpicture}
		\node[circle, draw] (a) at (1.7,0) {A};
		\node[circle, draw] (b) at (0,2) {B};
		\node[circle, draw] (c) at (4,0) {C};
		\node[circle, draw] (d) at (0,4) {D};
		\node[circle, draw] (e) at (2.5,2) {E};

		\draw[->, bend right, line width=1pt] (a) edge (b);
		\draw[->, bend right, line width=1pt] (a) edge (c);

		\draw[->, bend right, line width=1pt] (b) edge (a);
		\draw[->, line width=1pt] (b) edge (d);
		\draw[->, line width=1pt] (b) edge (e);

		\draw[->, line width=1pt] (c) edge (e);

		\draw[->, line width=1pt] (e) edge (a);

		\node at (2.5,3) {$w(x)=1\ \forall x\in V$};
	\end{tikzpicture}
	\end{center}


	\columnbreak

	
	\subsection*{Algorithms}
	\begin{description}
		\item[Single-Source Shortest-Paths (SSSP):] find the shortest path from a starting vertex to every other vertex

		\item[Breadth-first search (BFS):] find a node outgoing from a starting vertex, by increasing maximum hop count step-wise

		\item[PageRank (PR):] link analysis algorithm; weighs vertices, measuring their relative importance
	\end{description}
\end{multicols}


\clearpage
\begin{multicols}{2}
\section{Push Style}
\begin{center}
\begin{tikzpicture}
	\node[circle, draw] (a) at (1.5,1.2) {\bf A};
	\node[circle, draw] (b) at (0,0) {B};
	\node[circle, draw] (c) at (3,0) {C};
	\node[circle, draw] (d) at (1.5,3) {D};

	\draw[->, line width=1pt] (a) edge node[midway, above] {1} (b);
	\draw[->, line width=1pt] (a) edge node[midway, above] {1} (c);
	\draw[->, line width=1pt] (a) edge node[midway, right] {1} (d);
\end{tikzpicture}
\end{center}
\begin{itemize}
	\item reads active vertex, writes neighborhood 
	\item more efficient, if only few active vertices at the same time
	\item more efficient, if neighborhoods do not overlap
\end{itemize}


\columnbreak
\section{Pull Style}
\begin{center}
\begin{tikzpicture}
	\node[circle, draw] (a) at (1.5,1.2) {\bf A};
	\node[circle, draw] (b) at (0,0) {B};
	\node[circle, draw] (c) at (3,0) {C};
	\node[circle, draw] (d) at (1.5,3) {D};

	\draw[->, line width=1pt] (b) edge node[midway, above] {3} (a);
	\draw[->, line width=1pt] (c) edge node[midway, above] {2} (a);
	\draw[->, line width=1pt] (d) edge node[midway, right] {6} (a);
\end{tikzpicture}
\end{center}
\begin{itemize}
	\item reads neighborhood, writes active vertex
	\item[$\rightarrow$] only one write and many read operations
	\item less synchronization in parallel implementations needed
	\item more efficient, if many vertices active at the same time
\end{itemize}
\end{multicols}





\section{Hugepages}
\begin{itemize}
	\item most systems use virtual memory management
\begin{itemize}
	\item represents an abstraction to hardware memory
	\item virtual memory is then organized in pages
	\item translations of virtual memory to physical memory are cached, because every translation takes time
\end{itemize}
	\item typically, memory pages are 4 KiB in size
	\item \textbf{hugepages} can be several MiB in size $\rightarrow$ reduce number of cache misses
	\item especially noticeable in very memory intensive applications
\end{itemize}







\section{Frameworks}

\definecolor{Galois}{HTML}{1f77b4}
\definecolor{Gemini}{HTML}{ff7f0e}
\definecolor{Giraph}{HTML}{2ca02c}
\definecolor{Ligra}{HTML}{d62728}
\definecolor{Polymer}{HTML}{9467bd}

\begin{multicols}{2}
\begin{description}
	\item[$\color{Galois}\blacksquare$ Galois] is a general purpose library designed for parallel programming
	\begin{itemize}
		\item Version 6.0 from 29\textsuperscript{th} June 2020 used 
	\end{itemize}
	\item[$\color{Gemini}\blacksquare$ Gemini] uses a distributed message-based approach from scratch
	\begin{itemize}
		\item Version from 2\textsuperscript{nd} November 2016 used
		\item Version contains bugs that had to be fixed 
	\end{itemize}
	\item[$\color{Giraph}\blacksquare$ Giraph] is built on Apache Hadoop, a large scale data processing infrastructure
	\begin{itemize}
		\item Version 1.3 from 8\textsuperscript{th} May 2020 used
		\item BFS is not natively supported 
	\end{itemize}
	\item[$\color{Ligra}\blacksquare$ Ligra] dynamically switches between push and pull style
	\begin{itemize}
		\item Version from 14\textsuperscript{th} August 2019
	\end{itemize}
	\item[$\color{Polymer}\blacksquare$ Polymer] optimizes data layout and memory access strategies
	\begin{itemize}
		\item Version from 28\textsuperscript{th} August 2018
	\end{itemize}
\end{description}
\end{multicols}




\section{Evaluation}
\begin{multicols}{2}
\noindent 5 Machines, with
\begin{itemize}
	\item 96 cores, of which 48 virtual
	\item 256 GB of RAM each, one machine only 128 GB
	\item Ubuntu 18.04.2 LTS
\end{itemize}
\noindent Measurements:
\begin{itemize}
	\item \textbf{execution time}: time from start to finish of the console command
	\item \textbf{calculation time}: time the framework actually executed the algorithm
	\item \textbf{overhead}: time difference between execution time and calculation time \newline (time to read the input graph, initialization, etc.)
\end{itemize}

\columnbreak

\begin{center}
	\renewcommand{\arraystretch}{1.2}%
	\begin{tabular}{crr}
		\hline
		\bf{Graph}&\# Vertices (M)&\# Edges (M)\\\hline
		flickr&    		0.1&  2\\
		orkut&          3&    117\\
		wikipedia&      12&   378\\
		twitter&     	52&   1963\\
		rMat27&         63&   2147\\
		friendster&     68&   2586\\
		rMat28&         121&  4294\\
		\hline
	\end{tabular}
\end{center}


each test case (graph, framework, algorithm) was run 10 times
\end{multicols}



\clearpage
\begin{multicols}{2}
\section{Production Case}
\begin{itemize}
	\item running system, that performs multiple calculations on a single graph
	\item without the need of reloading graph data with every calculation
	\item short calculation times should be preferred because the overhead time is only spent once on startup and amortizes quickly
\end{itemize}

\columnbreak
\section{Research Case}
\begin{itemize}
	\item individual calculations on a graph, i.e. for each calculation, the graph has to be loaded
	\item the algorithm can change frequently
	\item requiring the framework to be relatively fast on different algorithms
	\item overall small execution times and small overhead are preferred
\end{itemize}
\end{multicols}


\section{Production Case Single Node}

\begin{figure}[h]
	\begin{subfigure}{0.32\textwidth}
		\includegraphics[width=\linewidth]{../../plots/singleNodeSSSP_calcTime.png}
		\caption{SSSP}
	\end{subfigure}
	\begin{subfigure}{0.32\textwidth}
		\includegraphics[width=\linewidth]{../../plots/singleNodeBFS_calcTime.png}
		\caption{BFS}
	\end{subfigure}
	\begin{subfigure}{0.32\textwidth}
		\includegraphics[width=\linewidth]{../../plots/singleNodePR_calcTime.png}
		\caption{PR}
	\end{subfigure}
\end{figure}
\begin{itemize}
	\item Giraph is either very slow or requires too much RAM (>256 GB)
	\item On SSSP, Polymer is fastest, followed by Gemini on second place
	\item On BFS, Gemini and Ligra are comparable and fastest on the larger graphs
	\item On PR, Galois is fastest. But we exclude Galois Push because of possible measuring errors.
	\item Message-based approach can compete with shared-memory
\end{itemize}


\section{Production Case Distributed}

\begin{figure}[h]
	\begin{subfigure}{0.32\textwidth}
		\includegraphics[width=\linewidth]{../../plots/distributedSSSP_calcTime.png}
		\caption{SSSP}
	\end{subfigure}
	\begin{subfigure}{0.32\textwidth}
		\includegraphics[width=\linewidth]{../../plots/distributedBFS_calcTime.png}
		\caption{BFS}
	\end{subfigure}
	\begin{subfigure}{0.32\textwidth}
		\includegraphics[width=\linewidth]{../../plots/distributedPR_calcTime.png}
		\caption{PR}
	\end{subfigure}
\end{figure}
\begin{itemize}
	\item Giraph is fastest on SSSP and BFS on the real world graphs
	\item Giraph has problems with synthetic graphs
	\item Gemini is fastest on PR, with Giraph on second place
\end{itemize}











\section{Research Case Single Node}

\begin{figure}[h]
	\begin{subfigure}{0.32\textwidth}
		\includegraphics[width=\linewidth]{../../plots/singleNodeSSSP_execTime.png}
		\caption{SSSP}
		\label{fig:singleNodeSSSP_exec}
	\end{subfigure}
	\begin{subfigure}{0.32\textwidth}
		\includegraphics[width=\linewidth]{../../plots/singleNodeBFS_execTime.png}
		\caption{BFS}
		\label{fig:singleNodeSSSP_exec}
	\end{subfigure}
	\begin{subfigure}{0.32\textwidth}
		\includegraphics[width=\linewidth]{../../plots/singleNodePR_execTime.png}
		\caption{PR}
		\label{fig:singleNodeSSSP_exec}
	\end{subfigure}
\end{figure}
\begin{itemize}
	\item Giraph is either slowest or requires too much RAM (>256 GB)
	\item Galois is fastest in almost all cases, second fastest is Ligra
	\item Gemini and Polymer are comparably slow
\end{itemize}


\section{Research Case Distributed}

\begin{figure}[h]
	\begin{subfigure}{0.32\textwidth}
		\includegraphics[width=\linewidth]{../../plots/distributedSSSP_execTime.png}
		\caption{SSSP}
		\label{fig:distributedSSSP_exec}
	\end{subfigure}
	\begin{subfigure}{0.32\textwidth}
		\includegraphics[width=\linewidth]{../../plots/distributedBFS_execTime.png}
		\caption{BFS}
		\label{fig:distributedSSSP_exec}
	\end{subfigure}
	\begin{subfigure}{0.32\textwidth}
		\includegraphics[width=\linewidth]{../../plots/distributedPR_execTime.png}
		\caption{PR}
		\label{fig:distributedSSSP_exec}
	\end{subfigure}
\end{figure}
\begin{itemize}
	\item Galois Push is faster than Pull in all cases
	\item Either Galois implementation is faster than any other frameworks on SSSP or BFS
	\item Gemini is fastest on PR and comparable to Giraph on SSSP and BFS
\end{itemize}


\section{Galois With Hugepages}
\begin{multicols}{2}
	

\begin{tabular}{ccr@{\tabskip 2 \tabcolsep}rr@{\tabskip 2 \tabcolsep}r}
		\toprule
		&&\multicolumn{2}{c}{\bf Calc Time (s)}&\multicolumn{2}{c}{\bf Exec Time (s)}\\
		\cmidrule{3-4}\cmidrule{5-6}
		&\bf Graph&w/o&w/&w/o&w/\\
		\midrule
\multirow{7}{0.5ex}{\rotatebox{90}{\bf SSSP}}
		& flickr & 0.01 & \bf 0.01 & 0.3 & \bf 0.2 \\
		& orkut & 0.10 & \bf 0.02 & 0.8 & \bf 0.5 \\
		& wikipedia & 0.38 & \bf 0.11 & 1.8 & \bf 1.1 \\
		& twitter & 2.47 & \bf 0.94 & 10.8 & \bf 5.1 \\
		& rMat27 & 4.50 & \bf 1.39 & 16.0 & \bf 6.4 \\
		& friendster & 4.70 & \bf 1.78 & 14.4 & \bf 7.5 \\
		& rMat28 & 9.77 & \bf 3.34 & 27.8 & \bf 13.1 \\
		\midrule
\multirow{7}{0.5ex}{\rotatebox{90}{\bf PR Pull}}
		& flickr & 0.01 & \bf 0.01 & 0.3 & \bf 0.2 \\
		& orkut & 0.06 & \bf 0.02 & 0.7 & \bf 0.6 \\
		& wikipedia & 0.17 & \bf 0.03 & 1.7 & \bf 1.4 \\
		& twitter & 0.77 & \bf 0.11 & \bf 8.7 & 9.3 \\
		& rMat27 & 0.65 & \bf 0.13 & 19.2 & \bf 8.1 \\
		& friendster & 1.01 & \bf 0.14 & 20.4 & \bf 13.1 \\
		& rMat28 & 1.15 & \bf 0.24 & 46.0 & \bf 16.4 \\
		\bottomrule
\end{tabular}

\columnbreak


	\includegraphics[width=0.7\linewidth]{../../plots/singleNodeSSSPGaloisHPThreads.png}
	SSSP

	\includegraphics[width=0.7\linewidth]{../../plots/singleNodePRPullGaloisHPThreads.png}
	PR Pull
\end{multicols}

\section{Conclusion and Outlook}
\begin{itemize}
	\item performance highly dependent on the framework, algorithm and data set
	\begin{itemize}
		\item Galois is almost always fastest in the research case; especially with hugepages
		\item Giraph is good on SSSP or BFS in distributed production
		\item Gemini is a good middleground for distributed PR and single node production
	\end{itemize}
	
	\item single node almost always preferrable, as long as RAM is sufficient
\end{itemize}


\subsection{Outlook}
\begin{itemize}
	\item[$\rightarrow$] incorporate new frameworks and new algorithms
	\item[$\rightarrow$] great range of settings and multiple implementations for the same problem
	\item[$\rightarrow$] At a later point in time, it is important to repeat such a comparison, because the frameworks are further developed and new ones are created.
\end{itemize}





\end{document}
